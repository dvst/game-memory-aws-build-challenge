<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>AWS Memory Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #232F3E 0%, #FF9900 100%);
            font-family: 'Courier New', monospace;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }
        
        #game-container {
            border: 6px solid #232F3E;
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(0,0,0,0.7);
            background: #000;
            position: relative;
            width: 800px;
            height: 600px;
        }
        
        #menu {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
            text-align: center;
        }
        
        .menu-title {
            font-size: 48px;
            margin-bottom: 20px;
            color: #FF9900;
            text-shadow: 4px 4px 0px #232F3E;
            letter-spacing: 3px;
        }
        
        .menu-subtitle {
            font-size: 16px;
            margin-bottom: 40px;
            color: #CCCCCC;
            max-width: 500px;
            line-height: 1.5;
        }
        
        .menu-button {
            background: linear-gradient(45deg, #FF9900, #FFB84D);
            color: #232F3E;
            border: 3px solid #232F3E;
            padding: 20px 40px;
            margin: 15px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            min-width: 200px;
        }
        
        .menu-button:hover {
            background: linear-gradient(45deg, #232F3E, #3A4A5C);
            color: #FF9900;
            border-color: #FF9900;
            transform: translateY(-2px);
        }
        
        .difficulty-info {
            display: flex;
            gap: 30px;
            margin-top: 30px;
        }
        
        .difficulty-card {
            background: rgba(255,255,255,0.1);
            border: 2px solid #FF9900;
            border-radius: 8px;
            padding: 20px;
            text-align: left;
            max-width: 200px;
        }
        
        .difficulty-title {
            color: #FF9900;
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 10px;
        }
        
        .difficulty-services {
            font-size: 14px;
            line-height: 1.4;
            color: #CCCCCC;
        }
        
        #ui {
            position: absolute;
            top: 15px;
            left: 15px;
            right: 15px;
            z-index: 999;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: white;
            font-size: 18px;
            font-weight: bold;
            background: rgba(0,0,0,0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border: 2px solid #FF9900;
        }
        
        .ui-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .ui-value {
            color: #FF9900;
            font-size: 20px;
        }
        
        .reset-button {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #FF6B6B;
            color: white;
            border: 2px solid #232F3E;
            padding: 8px 16px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 5px;
            z-index: 1001;
        }
        
        .reset-button:hover {
            background: #FF5252;
        }
        
        .hidden {
            display: none !important;
        }
        
        #phaser-game {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="menu">
            <div style="position: absolute; top: 20px; right: 20px;">
                <select id="language-selector" onchange="changeLanguage()" style="
                    background: #FF9900;
                    color: #232F3E;
                    border: 2px solid #232F3E;
                    padding: 8px 12px;
                    font-size: 14px;
                    font-weight: bold;
                    border-radius: 5px;
                    cursor: pointer;
                ">
                    <option value="es">üá™üá∏ Espa√±ol</option>
                    <option value="en">üá∫üá∏ English</option>
                </select>
            </div>
            
            <h1 class="menu-title" id="game-title">AWS MEMORY GAME</h1>
            <p class="menu-subtitle" id="game-subtitle">
                Pon a prueba tu conocimiento de los servicios de AWS en este divertido juego de memoria. 
                Encuentra los pares de servicios antes de que se acabe el tiempo.
            </p>
            
            <div class="difficulty-info">
                <div class="difficulty-card">
                    <div class="difficulty-title" id="easy-title">F√ÅCIL</div>
                    <div class="difficulty-services" id="easy-info">
                        ‚Ä¢ S3 - Simple Storage<br>
                        ‚Ä¢ Lambda - Functions<br>
                        ‚Ä¢ EC2 - Virtual Servers<br>
                        ‚Ä¢ RDS - Databases<br>
                        <strong>8 cartas (2√ó4) - 30s</strong>
                    </div>
                </div>
                
                <div class="difficulty-card">
                    <div class="difficulty-title" id="hard-title">DIF√çCIL</div>
                    <div class="difficulty-services" id="hard-info">
                        ‚Ä¢ EKS - Kubernetes<br>
                        ‚Ä¢ SageMaker - ML Platform<br>
                        ‚Ä¢ Kinesis - Data Streaming<br>
                        ‚Ä¢ Redshift - Data Warehouse<br>
                        ‚Ä¢ CloudFormation - IaC<br>
                        ‚Ä¢ ElastiCache - Cache<br>
                        ‚Ä¢ SNS - Notifications<br>
                        ‚Ä¢ SQS - Message Queue<br>
                        <strong>16 cartas (3√ó6) - 60s</strong>
                    </div>
                </div>
            </div>
            
            <div>
                <button class="menu-button" id="easy-button" onclick="startGame('easy')">Nivel F√°cil</button>
                <button class="menu-button" id="hard-button" onclick="startGame('hard')">Nivel Dif√≠cil</button>
            </div>
        </div>
        
        <div id="ui" class="hidden">
            <div class="ui-item">
                <span id="time-label">‚è±Ô∏è Tiempo:</span>
                <span class="ui-value"><span id="timer">30</span><span id="seconds-label">s</span></span>
            </div>
            <div class="ui-item">
                <span id="pairs-label">üéØ Pares:</span>
                <span class="ui-value"><span id="pairs">0/4</span></span>
            </div>
            <div class="ui-item">
                <span id="level-label">üìä Nivel:</span>
                <span class="ui-value" id="level">F√ÅCIL</span>
            </div>
        </div>
        
        <button id="reset-btn" class="reset-button hidden" onclick="resetToMenu()">üîÑ Reiniciar</button>
        
        <div id="phaser-game"></div>
    </div>

    <script src="public/lib/phaser.min.js"></script>
    <script>
        // Variables globales del juego
        let game = null;
        let cards = [];
        let flippedCards = [];
        let matchedPairs = 0;
        let totalPairs = 4; // Se actualizar√° seg√∫n el nivel
        let timeLeft = 30;
        let gameActive = false;
        let currentLevel = 'easy';
        let gameTimer = null;
        let currentLanguage = 'es'; // Idioma por defecto: espa√±ol

        // Textos en diferentes idiomas
        const translations = {
            es: {
                title: 'AWS MEMORY GAME',
                subtitle: 'Pon a prueba tu conocimiento de los servicios de AWS en este divertido juego de memoria. Encuentra los pares de servicios antes de que se acabe el tiempo.',
                easyLevel: 'Nivel F√°cil',
                hardLevel: 'Nivel Dif√≠cil',
                easyTitle: 'F√ÅCIL',
                hardTitle: 'DIF√çCIL',
                time: '‚è±Ô∏è Tiempo:',
                pairs: 'üéØ Pares:',
                level: 'üìä Nivel:',
                reset: 'üîÑ Reiniciar',
                won: '¬°GANASTE!',
                timeUp: 'TIEMPO AGOTADO',
                timeRemaining: 'Tiempo restante:',
                pairsFound: 'Pares encontrados:',
                seconds: 's',
                services: {
                    easy: [
                        { name: 'S3', description: 'Almacenamiento Simple' },
                        { name: 'Lambda', description: 'Funciones Serverless' },
                        { name: 'EC2', description: 'Servidores Virtuales' },
                        { name: 'RDS', description: 'Base de Datos' }
                    ],
                    hard: [
                        { name: 'EKS', description: 'Servicio Kubernetes' },
                        { name: 'SageMaker', description: 'Plataforma ML' },
                        { name: 'Kinesis', description: 'Streaming de Datos' },
                        { name: 'Redshift', description: 'Data Warehouse' },
                        { name: 'CloudFormation', description: 'Infraestructura como C√≥digo' },
                        { name: 'ElastiCache', description: 'Cache en Memoria' },
                        { name: 'SNS', description: 'Servicio de Notificaciones' },
                        { name: 'SQS', description: 'Cola de Mensajes' },
                        { name: 'DynamoDB', description: 'Base de Datos NoSQL' },
                        { name: 'CloudWatch', description: 'Monitoreo y Logs' }
                    ]
                },
                easyInfo: '‚Ä¢ S3 - Almacenamiento Simple<br>‚Ä¢ Lambda - Funciones<br>‚Ä¢ EC2 - Servidores Virtuales<br>‚Ä¢ RDS - Bases de Datos<br><strong>8 cartas (2√ó4) - 30s</strong>',
                hardInfo: '‚Ä¢ EKS - Kubernetes<br>‚Ä¢ SageMaker - Plataforma ML<br>‚Ä¢ Kinesis - Streaming de Datos<br>‚Ä¢ Redshift - Data Warehouse<br>‚Ä¢ CloudFormation - IaC<br>‚Ä¢ ElastiCache - Cache<br>‚Ä¢ SNS - Notificaciones<br>‚Ä¢ SQS - Cola de Mensajes<br>‚Ä¢ DynamoDB - NoSQL DB<br>‚Ä¢ CloudWatch - Monitoreo<br><strong>18 cartas (3√ó6) - 75s</strong>'
            },
            en: {
                title: 'AWS MEMORY GAME',
                subtitle: 'Test your knowledge of AWS services in this fun memory game. Find all service pairs before time runs out.',
                easyLevel: 'Easy Level',
                hardLevel: 'Hard Level',
                easyTitle: 'EASY',
                hardTitle: 'HARD',
                time: '‚è±Ô∏è Time:',
                pairs: 'üéØ Pairs:',
                level: 'üìä Level:',
                reset: 'üîÑ Reset',
                won: 'YOU WON!',
                timeUp: 'TIME\'S UP',
                timeRemaining: 'Time remaining:',
                pairsFound: 'Pairs found:',
                seconds: 's',
                services: {
                    easy: [
                        { name: 'S3', description: 'Simple Storage Service' },
                        { name: 'Lambda', description: 'Serverless Functions' },
                        { name: 'EC2', description: 'Virtual Servers' },
                        { name: 'RDS', description: 'Managed Database' }
                    ],
                    hard: [
                        { name: 'EKS', description: 'Kubernetes Service' },
                        { name: 'SageMaker', description: 'Machine Learning' },
                        { name: 'Kinesis', description: 'Data Streaming' },
                        { name: 'Redshift', description: 'Data Warehouse' },
                        { name: 'CloudFormation', description: 'Infrastructure as Code' },
                        { name: 'ElastiCache', description: 'In-Memory Cache' },
                        { name: 'SNS', description: 'Notification Service' },
                        { name: 'SQS', description: 'Message Queue' },
                        { name: 'DynamoDB', description: 'NoSQL Database' },
                        { name: 'CloudWatch', description: 'Monitoring & Logs' }
                    ]
                },
                easyInfo: '‚Ä¢ S3 - Simple Storage<br>‚Ä¢ Lambda - Functions<br>‚Ä¢ EC2 - Virtual Servers<br>‚Ä¢ RDS - Databases<br><strong>8 cards (2√ó4) - 30s</strong>',
                hardInfo: '‚Ä¢ EKS - Kubernetes<br>‚Ä¢ SageMaker - ML Platform<br>‚Ä¢ Kinesis - Data Streaming<br>‚Ä¢ Redshift - Data Warehouse<br>‚Ä¢ CloudFormation - IaC<br>‚Ä¢ ElastiCache - Cache<br>‚Ä¢ SNS - Notifications<br>‚Ä¢ SQS - Message Queue<br>‚Ä¢ DynamoDB - NoSQL DB<br>‚Ä¢ CloudWatch - Monitoring<br><strong>18 cards (3√ó6) - 75s</strong>'
            }
        };

        // Servicios AWS por dificultad (ahora se obtienen de las traducciones)
        function getAWSServices() {
            return {
                easy: translations[currentLanguage].services.easy.map(service => ({
                    name: service.name,
                    color: '#FF9900',
                    description: service.description
                })),
                hard: translations[currentLanguage].services.hard.map(service => ({
                    name: service.name,
                    color: '#FF9900',
                    description: service.description
                }))
            };
        }

        // Configuraci√≥n del juego Phaser
        const gameConfig = {
            type: Phaser.AUTO,
            width: 800,
            height: 600,
            parent: 'phaser-game',
            backgroundColor: '#1a1a2e',
            scene: {
                preload: preload,
                create: create,
                update: update
            }
        };

        function preload() {
            console.log('Preload iniciado');
            createCardTextures.call(this);
        }

        function create() {
            console.log('Create iniciado');
            
            // T√≠tulo del juego
            this.add.text(400, 80, 'AWS MEMORY GAME', {
                fontSize: '28px',
                fill: '#FF9900',
                fontFamily: 'monospace'
            }).setOrigin(0.5);
            
            setupCards.call(this);
            console.log('Juego creado exitosamente');
        }

        function update() {
            // L√≥gica de actualizaci√≥n
        }

        function createCardTextures() {
            const graphics = this.add.graphics();
            
            // Crear textura para carta volteada (reverso) con logo AWS pixelado
            graphics.fillStyle(0x232F3E);
            graphics.fillRoundedRect(0, 0, 120, 160, 10);
            graphics.lineStyle(4, 0xFF9900);
            graphics.strokeRoundedRect(2, 2, 116, 156, 10);
            
            // Dibujar logo AWS en estilo pixelado
            drawPixelatedAWSLogo(graphics, 60, 80);
            
            graphics.generateTexture('card-back', 120, 160);
            graphics.clear();
            
            // Lista fija de servicios para generar texturas (independiente del idioma)
            const allServiceNames = ['s3', 'lambda', 'ec2', 'rds', 'eks', 'sagemaker', 'kinesis', 'redshift', 'cloudformation', 'elasticache', 'sns', 'sqs', 'dynamodb', 'cloudwatch'];
            
            allServiceNames.forEach(serviceName => {
                try {
                    graphics.fillStyle(0xFFFFFF);
                    graphics.fillRoundedRect(0, 0, 120, 160, 10);
                    graphics.lineStyle(4, 0xFF9900);
                    graphics.strokeRoundedRect(2, 2, 116, 156, 10);
                    
                    // √Årea del icono
                    graphics.fillStyle(0xFF9900);
                    graphics.fillRoundedRect(10, 10, 100, 80, 5);
                    
                    // Dibujar icono del servicio
                    drawServiceIcon(graphics, serviceName, 60, 50);
                    
                    // √Årea del texto
                    graphics.fillStyle(0x232F3E);
                    graphics.fillRoundedRect(10, 100, 100, 50, 5);
                    
                    graphics.generateTexture(`card-${serviceName}`, 120, 160);
                    graphics.clear();
                } catch (error) {
                    console.error(`Error creando textura para ${serviceName}:`, error);
                    // Crear una textura b√°sica sin icono
                    graphics.fillStyle(0xFFFFFF);
                    graphics.fillRoundedRect(0, 0, 120, 160, 10);
                    graphics.lineStyle(4, 0xFF9900);
                    graphics.strokeRoundedRect(2, 2, 116, 156, 10);
                    graphics.fillStyle(0xFF9900);
                    graphics.fillRoundedRect(10, 10, 100, 80, 5);
                    graphics.fillStyle(0x232F3E);
                    graphics.fillRoundedRect(10, 100, 100, 50, 5);
                    graphics.generateTexture(`card-${serviceName}`, 120, 160);
                    graphics.clear();
                }
            });
            
            graphics.destroy();
        }

        function drawPixelatedAWSLogo(graphics, centerX, centerY) {
            // Configurar para dibujo pixelado
            graphics.fillStyle(0xFF9900);
            
            // Dibujar "AWS" en estilo pixel art
            const pixelSize = 3;
            
            // Letra A (primera)
            const aPattern = [
                [0,0,1,1,0,0],
                [0,1,0,0,1,0],
                [0,1,0,0,1,0],
                [0,1,1,1,1,0],
                [0,1,0,0,1,0],
                [0,1,0,0,1,0],
                [0,1,0,0,1,0]
            ];
            
            // Letra W
            const wPattern = [
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,0,0,1],
                [1,0,1,0,1],
                [1,0,1,0,1],
                [1,1,0,1,1],
                [1,0,0,0,1]
            ];
            
            // Letra S
            const sPattern = [
                [0,1,1,1,0],
                [1,0,0,0,0],
                [1,0,0,0,0],
                [0,1,1,1,0],
                [0,0,0,0,1],
                [0,0,0,0,1],
                [0,1,1,1,0]
            ];
            
            // Dibujar A
            drawPixelLetter(graphics, aPattern, centerX - 30, centerY - 15, pixelSize);
            
            // Dibujar W
            drawPixelLetter(graphics, wPattern, centerX - 8, centerY - 15, pixelSize);
            
            // Dibujar S
            drawPixelLetter(graphics, sPattern, centerX + 15, centerY - 15, pixelSize);
            
            // Dibujar la sonrisa caracter√≠stica de AWS (flecha curva)
            graphics.fillStyle(0xFF9900);
            
            // Flecha curva debajo del texto (simplificada en pixel art)
            const arrowY = centerY + 20;
            
            // L√≠nea principal de la flecha
            for (let i = 0; i < 8; i++) {
                graphics.fillRect(centerX - 24 + i * 6, arrowY + Math.sin(i * 0.5) * 3, pixelSize, pixelSize);
            }
            
            // Punta de la flecha
            graphics.fillRect(centerX + 18, arrowY - 3, pixelSize, pixelSize);
            graphics.fillRect(centerX + 21, arrowY, pixelSize, pixelSize);
            graphics.fillRect(centerX + 18, arrowY + 3, pixelSize, pixelSize);
            
            // Agregar algunos detalles decorativos pixelados
            graphics.fillStyle(0xFFB84D); // Color m√°s claro para detalles
            
            // Puntos decorativos
            graphics.fillRect(centerX - 35, centerY - 25, pixelSize, pixelSize);
            graphics.fillRect(centerX + 35, centerY - 25, pixelSize, pixelSize);
            graphics.fillRect(centerX - 35, centerY + 25, pixelSize, pixelSize);
            graphics.fillRect(centerX + 35, centerY + 25, pixelSize, pixelSize);
        }

        function drawPixelLetter(graphics, pattern, startX, startY, pixelSize) {
            for (let row = 0; row < pattern.length; row++) {
                for (let col = 0; col < pattern[row].length; col++) {
                    if (pattern[row][col] === 1) {
                        graphics.fillRect(
                            startX + col * pixelSize,
                            startY + row * pixelSize,
                            pixelSize,
                            pixelSize
                        );
                    }
                }
            }
        }

        function drawServiceIcon(graphics, serviceName, centerX, centerY) {
            graphics.fillStyle(0x232F3E);
            graphics.lineStyle(2, 0x232F3E);
            
            try {
                switch(serviceName.toLowerCase()) {
                    case 's3':
                        // Bucket S3 simple
                        graphics.fillRect(centerX - 15, centerY - 10, 30, 20);
                        graphics.strokeRect(centerX - 15, centerY - 10, 30, 20);
                        graphics.fillRect(centerX - 12, centerY - 6, 24, 2);
                        graphics.fillRect(centerX - 12, centerY - 2, 24, 2);
                        graphics.fillRect(centerX - 12, centerY + 2, 24, 2);
                        break;
                        
                    case 'lambda':
                        // Lambda simple
                        graphics.fillRect(centerX - 12, centerY - 12, 4, 24);
                        graphics.fillRect(centerX - 8, centerY - 8, 16, 4);
                        graphics.fillRect(centerX + 8, centerY - 12, 4, 24);
                        break;
                        
                    case 'ec2':
                        // Servidor simple
                        graphics.fillRect(centerX - 15, centerY - 12, 30, 24);
                        graphics.strokeRect(centerX - 15, centerY - 12, 30, 24);
                        graphics.fillCircle(centerX - 8, centerY - 6, 2);
                        graphics.fillCircle(centerX, centerY - 6, 2);
                        graphics.fillCircle(centerX + 8, centerY - 6, 2);
                        break;
                        
                    case 'rds':
                        // Base de datos simple
                        graphics.fillRect(centerX - 12, centerY - 8, 24, 16);
                        graphics.strokeRect(centerX - 12, centerY - 8, 24, 16);
                        graphics.fillRect(centerX - 10, centerY - 4, 20, 2);
                        graphics.fillRect(centerX - 10, centerY, 20, 2);
                        graphics.fillRect(centerX - 10, centerY + 4, 20, 2);
                        break;
                        
                    case 'eks':
                        // Kubernetes simple
                        graphics.strokeCircle(centerX, centerY, 12);
                        graphics.fillRect(centerX - 1, centerY - 12, 2, 24);
                        graphics.fillRect(centerX - 12, centerY - 1, 24, 2);
                        graphics.fillCircle(centerX, centerY, 3);
                        break;
                        
                    case 'sagemaker':
                        // ML simple
                        graphics.strokeCircle(centerX, centerY, 10);
                        graphics.fillRect(centerX - 8, centerY - 2, 16, 4);
                        graphics.fillCircle(centerX - 6, centerY, 2);
                        graphics.fillCircle(centerX + 6, centerY, 2);
                        break;
                        
                    case 'kinesis':
                        // Stream simple
                        graphics.fillRect(centerX - 15, centerY - 6, 30, 4);
                        graphics.fillRect(centerX - 15, centerY - 2, 30, 4);
                        graphics.fillRect(centerX - 15, centerY + 2, 30, 4);
                        // Flechas
                        graphics.fillRect(centerX + 10, centerY - 4, 4, 8);
                        break;
                        
                    case 'redshift':
                        // Data warehouse simple
                        graphics.fillRect(centerX - 15, centerY - 10, 30, 5);
                        graphics.fillRect(centerX - 15, centerY - 2, 30, 5);
                        graphics.fillRect(centerX - 15, centerY + 6, 30, 5);
                        graphics.strokeRect(centerX - 15, centerY - 10, 30, 5);
                        graphics.strokeRect(centerX - 15, centerY - 2, 30, 5);
                        graphics.strokeRect(centerX - 15, centerY + 6, 30, 5);
                        break;
                        
                    case 'cloudformation':
                        // CloudFormation - Stack de recursos
                        graphics.fillRect(centerX - 12, centerY - 8, 24, 4);
                        graphics.fillRect(centerX - 10, centerY - 4, 20, 4);
                        graphics.fillRect(centerX - 8, centerY, 16, 4);
                        graphics.fillRect(centerX - 6, centerY + 4, 12, 4);
                        graphics.strokeRect(centerX - 12, centerY - 8, 24, 4);
                        graphics.strokeRect(centerX - 10, centerY - 4, 20, 4);
                        graphics.strokeRect(centerX - 8, centerY, 16, 4);
                        graphics.strokeRect(centerX - 6, centerY + 4, 12, 4);
                        break;
                        
                    case 'elasticache':
                        // ElastiCache - Cache en memoria
                        graphics.strokeCircle(centerX, centerY, 12);
                        graphics.fillCircle(centerX - 6, centerY - 3, 2);
                        graphics.fillCircle(centerX + 6, centerY - 3, 2);
                        graphics.fillCircle(centerX, centerY + 6, 2);
                        graphics.fillRect(centerX - 8, centerY - 1, 16, 2);
                        break;
                        
                    case 'sns':
                        // SNS - Notification Service
                        graphics.strokeCircle(centerX, centerY, 10);
                        graphics.fillRect(centerX - 2, centerY - 6, 4, 12);
                        graphics.fillRect(centerX - 6, centerY - 2, 12, 4);
                        // Ondas de notificaci√≥n
                        graphics.strokeCircle(centerX, centerY, 14);
                        graphics.strokeCircle(centerX, centerY, 18);
                        break;
                        
                    case 'sqs':
                        // SQS - Message Queue
                        graphics.fillRect(centerX - 15, centerY - 8, 30, 4);
                        graphics.fillRect(centerX - 15, centerY - 2, 30, 4);
                        graphics.fillRect(centerX - 15, centerY + 4, 30, 4);
                        graphics.strokeRect(centerX - 15, centerY - 8, 30, 4);
                        graphics.strokeRect(centerX - 15, centerY - 2, 30, 4);
                        graphics.strokeRect(centerX - 15, centerY + 4, 30, 4);
                        // Flecha indicando flujo
                        graphics.fillRect(centerX + 12, centerY - 4, 2, 8);
                        graphics.fillRect(centerX + 10, centerY - 2, 6, 4);
                        break;
                        
                    case 'dynamodb':
                        // DynamoDB - NoSQL Database
                        graphics.strokeCircle(centerX, centerY, 12);
                        graphics.strokeCircle(centerX, centerY, 8);
                        graphics.strokeCircle(centerX, centerY, 4);
                        // Puntos de conexi√≥n
                        graphics.fillCircle(centerX, centerY - 12, 2);
                        graphics.fillCircle(centerX + 12, centerY, 2);
                        graphics.fillCircle(centerX, centerY + 12, 2);
                        graphics.fillCircle(centerX - 12, centerY, 2);
                        break;
                        
                    case 'cloudwatch':
                        // CloudWatch - Monitoring
                        graphics.strokeRect(centerX - 12, centerY - 8, 24, 16);
                        // Gr√°fico de l√≠neas
                        graphics.beginPath();
                        graphics.moveTo(centerX - 8, centerY + 2);
                        graphics.lineTo(centerX - 4, centerY - 2);
                        graphics.lineTo(centerX, centerY + 4);
                        graphics.lineTo(centerX + 4, centerY - 4);
                        graphics.lineTo(centerX + 8, centerY + 2);
                        graphics.stroke();
                        // Puntos de datos
                        graphics.fillCircle(centerX - 8, centerY + 2, 1);
                        graphics.fillCircle(centerX - 4, centerY - 2, 1);
                        graphics.fillCircle(centerX, centerY + 4, 1);
                        graphics.fillCircle(centerX + 4, centerY - 4, 1);
                        graphics.fillCircle(centerX + 8, centerY + 2, 1);
                        break;
                        
                    default:
                        // Icono por defecto
                        graphics.fillRect(centerX - 10, centerY - 10, 20, 20);
                        graphics.strokeRect(centerX - 10, centerY - 10, 20, 20);
                        break;
                }
            } catch (error) {
                console.error(`Error dibujando icono para ${serviceName}:`, error);
                // Icono de fallback
                graphics.fillRect(centerX - 8, centerY - 8, 16, 16);
            }
        }

        function setupCards() {
            const awsServices = getAWSServices(); // Obtener servicios traducidos
            const services = awsServices[currentLevel];
            const cardData = [];
            
            // Crear pares
            services.forEach(service => {
                cardData.push(service, service);
            });
            
            // Mezclar
            shuffleArray(cardData);
            
            // Configuraci√≥n seg√∫n el nivel
            const isHardMode = currentLevel === 'hard';
            const totalCards = isHardMode ? 18 : 8; // 18 cartas para modo dif√≠cil
            const cols = isHardMode ? 6 : 4;  // 6 columnas para modo dif√≠cil
            const rows = isHardMode ? 3 : 2;  // 3 filas para modo dif√≠cil
            
            // Calcular espaciado uniforme
            const canvasWidth = 800;
            const canvasHeight = 600;
            const cardWidth = 120;
            const cardHeight = 160;
            
            let cardScale, spacingX, spacingY, startX, startY;
            
            if (isHardMode) {
                // Para 18 cartas (3√ó6)
                cardScale = 0.6; // Cartas m√°s peque√±as
                const scaledCardWidth = cardWidth * cardScale;
                const scaledCardHeight = cardHeight * cardScale;
                
                // Calcular espaciado para que sea uniforme
                const totalCardsWidth = cols * scaledCardWidth;
                const availableSpaceX = canvasWidth - totalCardsWidth;
                spacingX = availableSpaceX / (cols + 1); // +1 para incluir bordes
                
                const totalCardsHeight = rows * scaledCardHeight;
                const availableSpaceY = canvasHeight - totalCardsHeight - 120; // -120 para UI superior
                spacingY = availableSpaceY / (rows + 1);
                
                startX = spacingX;
                startY = 120 + spacingY; // 120 para dejar espacio al UI
            } else {
                // Para 8 cartas (2√ó4) - sin cambios
                cardScale = 1.0;
                spacingX = 40;
                spacingY = 30;
                startX = 160;
                startY = 120;
            }
            
            cards = [];
            
            for (let i = 0; i < totalCards; i++) {
                const row = Math.floor(i / cols);
                const col = i % cols;
                
                const x = startX + col * (cardWidth * cardScale + spacingX);
                const y = startY + row * (cardHeight * cardScale + spacingY);
                
                const card = this.add.sprite(x, y, 'card-back')
                    .setInteractive()
                    .setOrigin(0)
                    .setScale(cardScale);
                
                card.cardData = cardData[i];
                card.isFlipped = false;
                card.isMatched = false;
                
                card.on('pointerdown', () => flipCard.call(this, card));
                card.on('pointerover', () => {
                    if (!card.isFlipped && !card.isMatched && gameActive) {
                        card.setTint(0xdddddd);
                    }
                });
                card.on('pointerout', () => {
                    if (!card.isFlipped && !card.isMatched) {
                        card.clearTint();
                    }
                });
                
                cards.push(card);
            }
        }

        function flipCard(card) {
            if (!gameActive || card.isFlipped || card.isMatched || flippedCards.length >= 2) {
                return;
            }
            
            card.isFlipped = true;
            card.setTexture(`card-${card.cardData.name.toLowerCase()}`);
            flippedCards.push(card);
            
            // Calcular posici√≥n del texto considerando la escala de la carta
            const cardScale = card.scaleX;
            const textX = card.x + (60 * cardScale);
            const textY = card.y + (130 * cardScale);
            const fontSize = currentLevel === 'hard' ? '10px' : '12px';
            
            // Agregar texto
            const text = this.add.text(textX, textY, card.cardData.name, {
                fontSize: fontSize,
                fill: '#FFFFFF',
                fontFamily: 'monospace',
                fontWeight: 'bold'
            }).setOrigin(0.5);
            
            card.serviceText = text;
            
            if (flippedCards.length === 2) {
                this.time.delayedCall(1000, () => checkMatch.call(this));
            }
        }

        function checkMatch() {
            const [card1, card2] = flippedCards;
            
            if (card1.cardData.name === card2.cardData.name) {
                // Match!
                card1.isMatched = true;
                card2.isMatched = true;
                card1.setTint(0x90EE90);
                card2.setTint(0x90EE90);
                
                matchedPairs++;
                document.getElementById('pairs').textContent = `${matchedPairs}/${totalPairs}`;
                
                if (matchedPairs === totalPairs) {
                    gameWon.call(this);
                }
            } else {
                // No match
                card1.isFlipped = false;
                card2.isFlipped = false;
                card1.setTexture('card-back');
                card2.setTexture('card-back');
                
                if (card1.serviceText) card1.serviceText.destroy();
                if (card2.serviceText) card2.serviceText.destroy();
            }
            
            flippedCards = [];
        }

        function gameWon() {
            gameActive = false;
            clearInterval(gameTimer);
            
            this.add.rectangle(400, 300, 800, 600, 0x000000, 0.8);
            this.add.text(400, 250, translations[currentLanguage].won, {
                fontSize: '48px',
                fill: '#90EE90',
                fontFamily: 'monospace'
            }).setOrigin(0.5);
            
            this.add.text(400, 320, `${translations[currentLanguage].timeRemaining} ${timeLeft}${translations[currentLanguage].seconds}`, {
                fontSize: '20px',
                fill: '#FFFFFF',
                fontFamily: 'monospace'
            }).setOrigin(0.5);
        }

        function gameOver() {
            gameActive = false;
            clearInterval(gameTimer);
            
            this.add.rectangle(400, 300, 800, 600, 0x000000, 0.8);
            this.add.text(400, 250, translations[currentLanguage].timeUp, {
                fontSize: '40px',
                fill: '#FF6B6B',
                fontFamily: 'monospace'
            }).setOrigin(0.5);
            
            this.add.text(400, 320, `${translations[currentLanguage].pairsFound} ${matchedPairs}/${totalPairs}`, {
                fontSize: '20px',
                fill: '#FFFFFF',
                fontFamily: 'monospace'
            }).setOrigin(0.5);
        }

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        function startTimer() {
            gameActive = true;
            gameTimer = setInterval(() => {
                timeLeft--;
                document.getElementById('timer').textContent = timeLeft;
                
                if (timeLeft <= 0) {
                    gameOver.call(game.scene.scenes[0]);
                }
            }, 1000);
        }

        // Funci√≥n para cambiar idioma
        function changeLanguage() {
            const selector = document.getElementById('language-selector');
            currentLanguage = selector.value;
            updateUI();
        }

        // Funci√≥n para actualizar toda la interfaz con el idioma seleccionado
        function updateUI() {
            const t = translations[currentLanguage];
            
            // Actualizar men√∫ principal
            document.getElementById('game-title').textContent = t.title;
            document.getElementById('game-subtitle').textContent = t.subtitle;
            document.getElementById('easy-title').textContent = t.easyTitle;
            document.getElementById('hard-title').textContent = t.hardTitle;
            document.getElementById('easy-info').innerHTML = t.easyInfo;
            document.getElementById('hard-info').innerHTML = t.hardInfo;
            document.getElementById('easy-button').textContent = t.easyLevel;
            document.getElementById('hard-button').textContent = t.hardLevel;
            
            // Actualizar UI del juego
            document.getElementById('time-label').textContent = t.time;
            document.getElementById('pairs-label').textContent = t.pairs;
            document.getElementById('level-label').textContent = t.level;
            document.getElementById('seconds-label').textContent = t.seconds;
            document.getElementById('reset-btn').innerHTML = t.reset;
        }

        // Funciones del men√∫
        function startGame(level) {
            console.log('Iniciando juego:', level);
            
            document.getElementById('menu').classList.add('hidden');
            document.getElementById('ui').classList.remove('hidden');
            document.getElementById('reset-btn').classList.remove('hidden');
            
            currentLevel = level;
            
            // Configurar seg√∫n el nivel
            if (level === 'hard') {
                totalPairs = 9; // 9 pares = 18 cartas
                timeLeft = 75; // M√°s tiempo para el modo dif√≠cil con m√°s cartas
            } else {
                totalPairs = 4;
                timeLeft = 30;
            }
            
            matchedPairs = 0;
            flippedCards = [];
            
            const t = translations[currentLanguage];
            document.getElementById('level').textContent = level === 'easy' ? t.easyTitle : t.hardTitle;
            document.getElementById('timer').textContent = timeLeft;
            document.getElementById('pairs').textContent = `0/${totalPairs}`;
            
            if (game) {
                game.destroy(true);
            }
            
            game = new Phaser.Game(gameConfig);
            
            setTimeout(() => {
                startTimer();
            }, 1000);
        }

        function resetToMenu() {
            if (gameTimer) clearInterval(gameTimer);
            if (game) {
                game.destroy(true);
                game = null;
            }
            
            cards = [];
            flippedCards = [];
            matchedPairs = 0;
            timeLeft = 30;
            gameActive = false;
            
            document.getElementById('menu').classList.remove('hidden');
            document.getElementById('ui').classList.add('hidden');
            document.getElementById('reset-btn').classList.add('hidden');
        }

        // Inicializaci√≥n
        window.addEventListener('load', () => {
            console.log('AWS Memory Game cargado');
            console.log('Phaser disponible:', typeof Phaser !== 'undefined');
            
            // Inicializar interfaz con idioma por defecto
            updateUI();
            
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape') {
                    resetToMenu();
                }
            });
        });
    </script>
</body>
</html>
